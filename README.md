# Assignment 4

## UVic CSC360 Spring 2025

**Due Friday, April 4, at 11:55 pm** via `push` to your `gitlab.csc`
repository, titled `a4`. Submissions must include:

1. A makefile titled `makefile` that creates an executable 
titled `virtmem` in your base directory, when run with command
`make virtmem`.

2. It is up to you how to structure your files and
code, but your submission must also include the code 
behind this `virtmem` executable - whether it is separated 
into 1 file, or 100.

To achieve same naming with minimal makefile code, it may be
simplest to name your main file `virtmem.c`. Consider, however,
that it may be of interest to create separate files to handle
separate parts of your implementation -- guaranteeing clear
separation of concerns.

**Note**: Use [`.gitignore`](https://git-scm.com/docs/gitignore/en) to ignore the 
files that should not be committed to the repository, e.g., the executable file, `.o`
object files, etc.

## Programming Platform

For this assignment your code must work on the UVic CSC Linux Servers, connection
to which was covered in Tutorial 1.  You may already have access to your own Unix 
system (e.g., Ubuntu, Debian, Cygwin on Windows 10, macOS with MacPorts, etc.) yet 
we recommend you work as much as possible with the Linux environment. 

Bugs in systems programming tend to be platform-specific and something that
works perfectly at home may end up crashing on a different
computer-language library configuration. (We cannot give marks for
submissions of which it is said “It worked in VSCode on my gaming laptop!”)

## Individual work

This assignment is to be completed by each individual student (i.e.,
no group work).  Naturally you will want to discuss aspects of the
problem with fellow students, and such discussions are encouraged.
However, **sharing of code is strictly forbidden**. If you are still
unsure about what is permitted or have other questions regarding
academic integrity, please direct them as soon as possible to the
instructor or member of the teaching team. (Code-similarity tools will
be run on submitted programs.) Any fragments of code found on the web
and used in your solution must be properly cited where it is used (i.e.,
citation in the form of a comment given source of code).

## Use of `gitlab.csc.uvic.ca`

Each student enrolled in the course has been assigned a Git repository
at `gitlab.csc.uvic.ca`. 

Please form the address of your repository appropriately **and if you
have not already done so** perform a `git clone` into your Linux Server
environment. You are also able to access this repository by going to
`https://gitlab.csc.uvic.ca` (and use your Netlink username and
password to log in at that page).

---

## Virtual-memory page replacement...


A starter file is provided to you as `appendix/virtmem.c` which already
contains significant functionality intended to reduce your work. 

This goal requires you to simulate the actions of a virtual-memory subsystem. Specifically you are to take a sequence of logical memory operations generated by a target process and "convert" them into physical addresses. In reality, however, you will not be running a target process but instead using a memory trace generated for you already (using an application suite from Intel called `pin`) and stored into a text file. You are provided with a code skeleton named above (`appendix/virtmem.c`) which currently reads in memory operations contained in a specified trace file and calls the `resolve_address()` function for each operation. This skeleton code also finds a free frame **but does not replace pages when the simulated memory is full.**

Here are the first few lines from a memory trace generated by a "Hello, World!" program:

```
I: 0x7feee195f090
I: 0x7feee195f093
W: 0x7ffe23dd2e88
I: 0x7feee195fea0
W: 0x7ffe23dd2e80
I: 0x7feee195fea1
I: 0x7feee195fea4
W: 0x7ffe23dd2e78
I: 0x7feee195fea6
```

Each line starts with a leading `I`, `W`, or `R` (standing for "instruction read", "memory write", or "memory read" respectively). This single character (and a trailing colon) is followed on the line by a virtual-memory address in hexadecimal. The address must be converted into a physical address, and it is this conversion step -- and much that is needed to make it happen by way of data structures and algorithms -- that your code will simulate.

A few trace files generated by `pin` are in the `appendix/traces/` directory of your repository.

---

**Three different algorithms to be implemented...**

Your programming tasks within `virtmem.c` are therefore: 
* to modify `resolve_address()`;
* to modify the `struct page_table_entry` data structure (if necessary), modify `startup()` and `teardown()` functions (if necessary), 
* add functions (if necessary)
* to implement a simulation the `FIFO`, `LRU` and `CLOCK` page-replacement algorithms.

Note that `resolve_address()` takes two parameters (the **logical address** and whether the operation on the address **is a read or write**) and returns one value (the physical address).

* The simulator is invoked on the command line when running `virtmem`.
* The algorithm to be used is indicated by a command-line argument 
(`--replace=fifo`, `--replace=lru` or `--replace=clock`).
* The size of a simulated physical frame is indicated at the command line (`--framesize=8` specifies physical frames of size 256 bytes each, i.e., 2^8). Note that the frame size is forced to be a power-of-two.
* The size of the simulated physical memory is indicated at the command line (`--numframes=256` specifies a simulated memory where there are 256 frames). **There is no requirement that the number of frames must be a power-of-two!**
* The file containing the memory trace is indicated at the command line (`--file=hello_out.txt`). These traces are provided to you.
* A progress-bar is enabled via the `--progress` command-line argument.

Some functionality is already provided for you by the skeleton code. For example, it handles the processing of command line arguments. It also handles the reading of trace files, and splitting virtual memory addresses into the page-number of offset components. (Recall that these latter details depend for correct operation upon the value provided as the frame size when running the simulator.)

As an example, `appendix/traces/hello-out.txt` contains a textual
representation of the memory operations generated by running a `hello,
world` command on a x86 virtual machine that I've used. Assuming you
have compiled the skeleton `virtmem.c` within the CSC Linux Servers, are running
the program from the `appendix/` directory, and have the trace files
available in `appendix/traces/`, the following will appear (i.e.
skeleton code without FIFO page-replacement yet implemented) where the
frame size is 2^12 bytes in size, where there are 256 such physical
frames, and the progress bar is printed. (The scheme below is
specified as FIFO, but this has no effect in the skeleton code!)

```
./virtmem --file=traces/hello-out.txt --framesize=12 \ 
    --numframes=256 --replace=fifo --progress
```

and here is the output:
```
Progress [............................................................] 100%
Memory references: 127926
Page faults: 119
Swap ins: 119
Swap outs: 0
```

It so happens that the trace above was “simulated to completion”. If we change the number of frames to a smaller number:

```
./virtmem --file=traces/hello-out.txt --framesize=12 \ 
    --numframes=100 --replace=fifo --progress
```

and here is the output for **that** run:

```
Progress [.......................................................     ]  92%
Simulator error: cannot resolve address 0x7fec99b82170 at line 120024
```

The line number message indicates that the simulator attempted to resolve the memory access indicated by line 120024 within `hello-out.txt`, but could not do so. In this case the error results from there no longer existing any more free frames (i.e., the skeleton file does not implement page replacement!).

---

**And a word about "Swap outs" and "Swap ins":**

* When a page is first loaded into a frame (i.e. within a fully-implemented operating systems), the contents of that page are either obtained from the file system (i.e. code for the program, or global variables with initial values also stored in the program’s binary) or the contents of the page are zeroed out (i.e. region of memory corresponding to the page is for uninitialized local and global data). If the physical frame corresponds to a page in which data is stored, then the contents of that page must be stored onto disk if the frame is chosen for replacement; and because we cannot reconstruct the page from the program’s binary, that frame must be stored in swap space. This action of saving a frame’s content onto disk is called a "swap out".
  
* If there is a fault on a particular page, and if that page had previously been mapped to a physical frame, and if that frame had been swapped out, then servicing the page fault must include reading back into the memory the contents of the physical frame as it had been stored within the swap space. This action of loading a frame’s content into disk is called a "swap in". To simplify your logic, you can consider any load of a frame’s contents (including those for code or the first use of initialized global data) as a "swap in".

**You must keep track of the number of swap ins and swap outs that would be required giving the simulations parameters and the addresses that make up the simulation.**

---

**To sum up, you are to...**

* Implement a `FIFO` page replacement scheme and update the appropriate global variables so `output_report()` works. 
* Implement an `LRU` page replacement scheme and update the appropriate global variable, ditto comments about `output_report()`.
* Implement a `CLOCK` page replacement scheme and update the appropriate global variable, ditto comments about `output_report()`.
* Keep track of the number of swap-ins and swap-outs.
* Test your implementation with a variety of trace files, frame sizes and memory sizes.
* Make sure your operations work on 64-bit addresses (i.e., long ints). You’ll get weird and hard-to-debug error messages if you depend too much upon 32-bit integers (i.e., regular ints).

---

## Some useful tips & functions that may help

Based on feedback, here are some helpful C standard library functions that may
be of use in your implementation. They may or may not be useful... In fact, you may find their use overcomplicates your solution. 
Regardless, they are relevant espcially when implementing true virtual memory management, beyond our simulation case:

`malloc`, `calloc`, `realloc`, `free`: Essential for dynamic memory allocation. `calloc` is particularly useful as it initializes memory to zero, which can prevent issues with uninitialized data.

`memcpy`, `memset`: Useful for operations on memory blocks, which could be helpful for manipulating page table entries.

`qsort` (quick sort): Can be useful for implementing LRU by sorting pages based on their last access time.

`bsearch` (binary search): For optimizing page lookups in larger page tables.

More information about all of these functions may be found via documentation, or more visually here: https://www.tutorialspoint.com/c_standard_library/stdlib_h.htm.

### Data Structure Miscellany:

There is a plethora of appropriate choices here, but for ease-of-development you may find the following helpful to guide your thinking; particularly if your memory of Algorithms & Data Structures is a bit rusty.

* For your FIFO implementation, you should consider FIFO structures you may have seen persistently throughout our assignments this term (ahem, linked-list based queue?).

* For your LRU, an array with timestamps or a more sophisticated ordered structure may be appropriate.

* For Clock: Circular buffer? See: https://en.wikipedia.org/wiki/Circular_buffer


## Some Sample output: 

The following is all run with the following command, simply replacing the replacement scheme.
Note that you may not get the exact same output. Please aim for the same, however we are aware
that individual implementations may vary by a *small* amount. 

```
./virtmem --file=hello-out.txt --framesize=12     --numframes=100 --replace=fifo --progress
```


### (FIFO) 


```
Progress [............................................................] 100%
Memory references: 127926
Page faults: 131
Swap ins: 131
Swap outs: 7
```

### (LRU) 
```
Progress [............................................................] 100%
Memory references: 127926
Page faults: 119
Swap ins: 119
Swap outs: 1
```

### (CLOCK) 
```
Progress [............................................................] 100%
Memory references: 127926
Page faults: 123
Swap ins: 123
Swap outs: 3
```


## Evaluation

**Note: Up to five students may each be asked to demonstrate their work to
the teaching team before their final assignment evaluation is provided
to them.**

You may notice that the starter code contains traces of "optimal" page replacement scheme.
A 20% bonus mark will be awarded for completing an optimal (aka Clairvoyant, aka Belady's 
optimal) page replacement scheme. If you complete this, please add a `README.md` file in 
your base directory stating that you have completed this bonus. This bonus may overflow 
but not exceed the weight for all assignments.

80% of the mark for this assignment is related to implementation *correctness*, and
will be evaluated by automated testing scripts. There are between 8-16 test cases,
marks will be distributed equally across these test cases. The test cases will be
released after the marks are complete, to allow for students to self-evaluate their
code in case of any marking issues. 

20% of the mark for this assignment will pertain to code quality. While code quality
is often perceived as a fairly objective quality, we can establish a general playbook
to consider while developing code:

- Proper decomposition of a program into subroutines — A 500 line program as a single
routine won't suffice.
- Comment - judiciously, but not profusely. Comments serve to help a marker. To further
elaborate:
  - Your favorite quote from Star Wars does not count as comments. In fact, they simply
  count as anti-comments, and will result in a loss of marks.

- Proper variable names, `int a;` is not a good variable name, it never was and never will
be.
- Small number of global variables, if any. Most programs need a very small number of global
variables, if any. (If you have a global variable named temp, think again.)
- The return values from all system calls should be checked and all values should be dealt
with appropriately.
- If you are in doubt about how to write good C code, you can easily find many C style guides
on the Net. 
The Indian Hill Style Guide http://www.cs.arizona.edu/~mccann/cstyle.html is an excellent short
style guide.


---

Special thanks to M. Zastre for original assignment structure and concept. Modifications made by Konrad Jasman for ease of marking, clarity and streamlining development in the Spring 2025 term.

